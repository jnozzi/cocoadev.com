

Collection of error messages using Core Data and what caused them (including incorrect bindings). Feel free to add your own - hopefully next time you see one of these, this will remind you why. **See also CoreDataBindingsProblems** - PaulCollins

If you find this page useful, please file bugs on these issues so Apple makes it easier to use Core Data.  Cut and Paste if you like.


* ** [<NSTableColumn 0x3a13e0> valueForUndefinedKey:]: this class is not key value coding-compliant for the key value.** Error generated by forgetting to remove the value binding when I re-used a column and put in push buttons (NSButtonCell). Cells like this don't have value binding, although it remains if you bound something before putting in the NSButtonCell. Also got signal SIGTRAP. The workaround is to get the nib file's info pane and hit the Reset All Objects button.

* ** -[My<nowiki/>ClassName copyWithZone:]: selector not recognized [self = 0x3613e0] **   Forgot to specify field to show in NSTableColumn bound to relationship

* **NSTimer discarding exception 'Can't use in operator with rhs 1 (not a collection)' that raised during firing of timer with target 39c9b0 and selector '_sendPartialString' ** when typing in NSSearchField. Cause: A Predicate Format in one or more search predicates contains an attribute name that doesn't exist or is misspelled. Did you change your model and not re-do your search field?

* **NSRunLoop ignoring exception 'Cannot perform operation without a managed object context' that raised during posting of delayed perform with target 15a27340 and selector 'invokeWithTarget:**' In nib, an NSController (subclass)'s managedObjectContext is not bound to your controller (or document?) instance containing a managed object context.  *Not necessarily "in a nib" - this can happen if you bind controls manually (in code) as well.*

* **NSRunLoop ignoring exception 'unresolved keypath: fullNameAndID' that raised during posting of delayed perform with target 15a3a6a0 and selector 'invokeWithTarget:**' occured when opening a saved data file after adding a "fullNameAndId" binding to an interface object (this was in NSPersistentDocument Core Data Tutorial). You can't open old documents after changing the model--this versioning issue is discussed in the dev docs.

* **EXC_BAD_ACCESS from infinite recursion of -[NSCFNumber retain] within _startObservingModelObject** Pop-up list bound to NSArrayControlled incorrectly. Controller is an array of NSNumbers (pop-up options are 1-5). Popup was using ContentValues binding, but in this case you should bind ContentObjects, as well as Content (to arrangedObjects of controller), plus selected object as <entity>.<int-attributename>

* **exception: Cannot perform operation since entity with name '(null)' cannot be found (when saving file).**' An NSObjectController's Entity name attribute was not set. This will also occur during a 'Save as' operation if an NSObjectController is set to Class mode and simultaneously is bound to a managed object context.

* **exception on -save: [NSCFDictionary setObject:forKey:]: attempt to insert nil key**' -or- (on relaunch) **The model configuration used to open the store is incompatible with the one that was used to create the store.**' This may be a Configurations issue. You have a core data stack (i.e., Context) with a named Configuration, but it contains managed objects of Entities that don't belong to that Configuration or have relationships to Entities that don't belong to that Configuration. Check your model for new objects that you forgot to check the Configuration box on. Configuration names are case sensitive. - TheModelConfigurationUsedToOpenTheStoreIsIncompatibleWithTheOneThatWasUsedToCreateTheStore

* **In the xml store file, some objects have     type="" with attributes'     name=""** This is another symptom of the above Entity-without-specified-Configuration issue.

* **error object returned by -save: "<attribute name> is a required value"  or  "Too few items in <to-many relationship name>�**  �Optional� is unchecked for this item in the model, yet the value was not set. 


----
Non-error problems


* **Attribute returns/displays wrong data.** Attribute and relationship names cannot be the same as any no-parameter method name of NSObject or NSManagedObject (such as 'version' or 'description'). I infer this includes all informal protocol no-parameter methods.  So far, I've seen no warning when using an NSObject method name, you just get the wrong data back. See the Class Description of NSPropertyDescription.

* **-executeFetchRequest returns zero objects when using -predicateWithSubstitutionVariables** One cause: If you substitute the attribute name (as opposed to the search value), you must use predicateWithFormat: and %K placeholder. Anything else puts quote marks around the substitution, which is not acceptable for attribute names.

* **In the xml store file, object types and attribute names are empty strings.** Configurations issue. This is the same problem that causes "exception...attempt to insern nil key" (see above in error list), except you don't need relationships to have the problem.
        <object type="" id="z102">
        <attribute name="" type="string">abc</attribute>




* **- selector not recognized [self = 0x30e340]** Two causes: 1) You misspelled the name of an entity or attribute when you set the attributes, connections or bindings of your objects in Interface Builder. Check your capitalizations and just stupid typos. 2) You made a change in your data model (renamed or added attributes or entities) and those changes were never written to the underlying sqlite database, because Core Data doesn't do that for you (it's in the documentation, look under persistent store migration). Solution: migrate your database or [warning: *unofficial* workaround] adjust the sqlite database by hand, following the core data's naming conventies (entity 'Dogs' with attribute 'name' of type string and relationship 'breed' will look something like table 'ZDOGS' with fields 'ZNAME' of type VARCHAR and 'ZBREED' of type INTEGER). The workaround is entirely at your own risk but it does work.


----
Error Messages with Unknown Causes (Requests for Help)


* **YYYY-MM-DD hh-mm-ss.### AppName[#####] -[NSAutoreleasePool dealloc]: Exception ignored while releasing an object in an autorelease pool: The NSManagedObject with ID:... <x-coredata:///.../...> has been invalidated.** Unknown cause. Looking for means to debug by setting a breakpoint to stop at the exception that Cocoa so 'conveniently' ignores (NSZombieEnabled seemed like a good option, but I couldn't get it to work)
----To see the invalid object: In the saved xml file version of your data (the persistent store file), search for the number at the end of the ID URI (like "x-coredata://.../.../p123"). That won't work if the object has never been saved, though. See if the CD Programming Guide sections "Memory Management Using Core Data" or "Faulting and Uniqing" provide a clue.
----
This can be caused by KVO notifications firing on an object that has been faulted.  If you've got KVO happening in your app, for example your Child object instance is observing your Parent, then make sure - that when the Parent faults - the Child stops observing the Parent - otherwise, when the parent changes (eg. its values become nil during faulting/dealloc), the Child will get a notification and will then try to access the parent.  Bad news if the Parent has faulted and dealloced at that point.
----
I was getting this error during dealloc of my Managed Object, while diligently (and I guess stupidly) using self.attribute = nil to release properties. Easy mistake to make when turning a normal class into a Managed Object class!


----
The document "Untitled" could not be saved. Could not merge changes.
I was having a problem where I was getting this error every time I modified any data. It didn't occur with NSBinaryStoreType or NSXMLStoreType but it happened every time with NSSQLiteStoreType. Also I was forcing the app to open the document with openDocumentWithContentsOfURL and forcing the type inside  configurePersistentStoreCoordinatorForURL.

It turns out that somehow the framework gets confused if the document you open with openDocumentWithContentsOfURL has a file extension that doesn't match that you've specified in your Info.plist's CFBundleTypeExtensions. I don't see why this should be a problem since it correctly opened the document anyway, it just bombs when trying to modify it and save it again. So the error message has no apparent relation to the cause.
*
